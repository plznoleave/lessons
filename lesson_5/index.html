<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <title>Плавность анимации CSS</title>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="header-content-block smoothness">
                <div class="content-block">
                    <h1>Плавность анимации CSS: миф или реальность</h1>
                    <p>Меня зовут Виталий Калашников, и я Senior Front-end Developer в компании AB Soft. В веб-разработке 5 лет. За это время я поработал над проектами с различным стеком: начиная с WordPress, Magento, заканчивая YII2 и Larevel. Самое интересное, где мне удавалось писать код, — UMI.CMS. Придя в компанию, в которой разделены обязанности между Back-end и Front-end, я начал углубляться во Front-end, так и начался мой переход на путь истинный.</p>
                    <p>В последнее время я стал осваивать и реализовывать всевозможные эффекты в анимации и анализировать, почему все-таки мне не удается достичь максимальной плавности анимируемых элементов. После некоторых тестов и исследований понял, что при выполнении анимации проседает fps. Начал копать глубже, смотреть, как браузер отрисовывает элементы на странице, в какой последовательности и прочее, и понял, что на некоторых этапах браузер теряет свои заветные кадры. Так родилась идея этой статьи. В ней я постараюсь поделиться своими наработками и показать набитые шишки. Буду рад комментариям и обратной связи.</p>
                    <span>Навигация по статье:</span>
                    <ol>
                        <li>
                            <a href="#flashback-header">Короткий флешбэк в историю анимации.</a>
                        </li>
                        <li>
                            <a href="#way-header">Критический путь рендеринга.</a>
                        </li>
                        <li>
                            <a href="#reflow-repaint-header">Reflow и Repaint.</a>
                        </li>
                        <li>
                            <a href="#composition-header">Композиция.</a>
                        </li>
                        <li>
                            <a href="#speed-header">Как ускорить анимацию.</a>
                        </li>
                        <li>
                            <a href="#track-header">Как отследить работу анимации в браузере</a>
                        </li>
                        <li>
                            <a href="#differences-header">Чем отличаются JS и CSS и что лучше использовать для создания анимации.</a>
                        </li>
                        <li>
                            <a href="#conclusions-header">Советы и выводы.</a>
                        </li>
                    </ol>
                </div>
            </div>
        </div>
    </header>
    <main>
        <div class="main-content">
            <div class="main-content-block flashback">
                <div class="content-block">
                    <h2 id="flashback-header">Короткий флешбэк в историю анимации</h2>
                    <p>Прежде чем говорить об ускорении анимации, вспомним не столь далекий 2011 год, когда для ее создания использовались GIF, Flash и JS. Все эти методы хороши, но каждый имеет свой недостаток: GIF — это плюс один реквест для браузера, Flash — уже прошлый век, ну а JS для создания простейшей анимации довольно сложен.</p>
                    <p>В том же году вниманию IT-специалистов представили CSS3, в котором появилась возможность создавать:</p>
                    <ul>
                        <li>&#10066; скругленные рамки;</li>
                        <li>&#10066; тени для блоков и текста;</li>
                        <li>&#10066; множественные фоны;</li>
                        <li>&#10066; градиенты и шрифты;</li>
                        <li><span>&#10066; ну и анимацию, появление которой в CSS3 было революционным.</span></li>
                    </ul>
                    <div class="content-img">
                        <img src="img/01.png" alt="Структура css анимации" title="Структура css анимации">
                    </div>
                    <p>Прежде чем перейти к ускорению анимации, проанализируем, из каких этапов она состоит и что влияет на ее скорость.</p>
                </div>
            </div>
            <div class="main-content-block way">
                <div class="content-block">
                    <h2 id="way-header">Критический путь рендеринга</h2>
                    <p>Для первичной отрисовки страницы браузер совершает определенную последовательность действий. Ее называют критическим путем рендеринга (Critical Rendering Path, или CRP). Рассмотрим четыре основных шага CRP, чтобы понять, на каком из них анимацию можно ускорить:</p>
                    <div class="content-img">
                        <img src="img/02.png" alt="Шаги CRP" title="Шаги CRP">
                    </div>
                    <ol>
                        <li>&#10066; На стадии Styles к элементам применяют стили.</li>
                        <li>&#10066; На этапе Layout происходит подготовка места для элементов. Обычно мы указываем высоту и ширину элемента, а браузер подготавливает для него определенное место, чтобы он правильно отрисовался.</li>
                        <li>&#10066; На этапе Paint элементы анимации заполняются цветом; применяются такие свойства, как text shadow или box shadow.</li>
                        <li>&#10066; Следующий шаг — это композиция, или Composite. Браузер начинает размещать элементы один относительно другого. Если есть элементы, которые наложены один на другой, то браузер «сообразит», как это отрисовать и какой элемент находится выше по Z-индексу, а какой ниже.</li>
                    </ol>
                    <p>Говоря о создании визуальных эффектов, мы обычно оперируем двумя терминами — Reflow и Repaint.</p>
                </div>
            </div>
            <div class="main-content-block reflow-repaint">
                <div class="content-block">
                    <h2 id="reflow-repaint-header">Reflow и Repaint</h2>
                    <p>Предположим, перед нами стоит следующая задача: проанимировать элемент, увеличить его размер, изменить высоту или ширину. Если это делать с помощью таких свойств, как height и width, то браузеру придется проходить все четыре шага заново: опять применять стили, отрисовывать макет, заполнять цветом элементы, делать компоновку... И это будет касаться каждого кадра вашей анимации. То есть если вам необходимо увеличить элемент на 10 пикселей, то страница будет перерисовываться 10 раз. Естественно, это все повлияет и на скорость, и на качество анимации.</p>
                    <div class="content-img">
                        <img src="img/03.png" alt="Шаги CRP" title="Шаги CRP">
                    </div>
                    <p>Что касается исключительно процесса Repaint, то в этом случае шаг Layout будет отсутствовать. Так как элемент не изменил ни размер, ни свое позиционирование на плоскости. Такое случается, когда вы делаете ховер на элемент, например заливаете его новым бэкграундом.</p>
                    <div class="content-img">
                        <img src="img/04.png" alt="Шаги CRP" title="Шаги CRP">
                    </div>
                    <p>И мой любимый этап, No reflow and No Repaint, самый выгодный для браузера шаг. Так можно добиться того, чтобы не затрагивалась смена макета и отрисовка не происходила заново. Достигнуть этого можно с помощью трансформа.</p>
                    <div class="content-img">
                        <img src="img/05.png" alt="Шаги CRP" title="Шаги CRP">
                    </div>
                </div>
            </div>
            <div class="main-content-block composition">
                <div class="content-block">
                    <h2 id="composition-header">Композиция</h2>
                    <p>Остановимся подробнее на шаге «Композиция», потому что именно от него зависит, насколько плавной будет анимация. На этой стадии браузер, прежде чем отрисовать страницу, проходит несколько шагов:</p>
                    <ul>
                        <li>&#10066; страница делится на слои так, чтобы элементы в браузере не перекрывали друг друга и отрисовка была правильной;</li>
                        <li>&#10066; слои растеризируются;</li>
                        <li>&#10066; слои выводятся на экран.</li>
                    </ul>
                </div>
            </div>
            <div class="main-content-block speed">
                <div class="content-block">
                    <h2 id="speed-header">Как ускорить анимацию</h2>
                    <p>Как, зная все вышесказанное, ускорить анимацию? С помощью аппаратного ускорения (или ускорения графики).</p>
                    <p>При аппаратном ускорении графический процессор помогает браузеру отрисовывать страницу путем выполнения некоторых сложных задач, а не сваливает всю работу на центральный процессор. В момент, когда CSS-операция получает аппаратное ускорение, происходит скачок скорости и отрисовка страницы выполняется быстрее.</p>
                    <p>Известно, что центральный процессор размещен на материнской плате компьютера и является его мозгом. В свою очередь, графический процессор (ГП) размещён на графической карте и отвечает за обработку и отрисовку графики. Он создан специально для выполнения сложных математических и геометрических вычислений, требуемых для отрисовки графики, поэтому если переложить груз некоторых операций на ГП, то получим существенное повышение быстродействия и снижение загрузки центрального процессора на мобильных девайсах.</p>
                    <p>В основе аппаратного ускорения — иерархическая модель, используемая браузером при отрисовке страницы. Когда с элементом на странице проводятся определенные операции (такие, как 3D-трансформации), он перемещается на свой собственный «слой», где может отрисовываться независимо от остальной страницы и выводиться на экран позже. Это изолирует отрисовку содержимого так, что остальную часть страницы не нужно отрисовывать повторно, если трансформация элемента — это единственное изменение между фреймами. Такой порядок часто положительно влияет на скорость отрисовки.</p>
                    <p>Итак, при аппаратном ускорении:</p>
                    <ul>
                        <li>&#10066; страница делится на слои;</li>
                        <li>&#10066; слои растеризируются в текстуры;</li>
                        <li>&#10066; текстуры помещаются в GPU — и мы можем смело говорить, что теперь за анимацию будет отвечать видеокарта;</li>
                        <li>&#10066; браузерный композитор инструктирует GPU, как собрать конечное изображение. На этом шаге создается отдельный <a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome/" target="_blank" title="Композитный слой - переход на сайт">композитный слой</a> — часть страницы, которая отрисовывается и компонуется независимо на GPU (поддерево DOM). Он может растягиваться, перемещаться и скрываться без отрисовки. Это важно, поскольку отрисовка — довольно ресурсоемкий процесс, из-за которого в том числе может глючить анимация.</li>
                    </ul>
                    <p>Как добавлять в этот композитный слой элементы:</p>
                    <ol>
                        <li>&#10066; 3D-трансформация (элементы анимируются с помощью translate3D, translateS).</li>
                        <li>&#10066; Элементы <span>&lt;video&gt;, &lt;canvas&gt;, &lt;frame&gt;</span>. Точно так же создается композитный слой и обрабатывается на GPU.</li>
                        <li>&#10066; Анимация через transform, opacity и CSS Transition Animation.</li>
                        <li>&#10066; position; fixed.</li>
                        <li>&#10066; will change. Это свойство не только подсказывает браузеру, как будет меняться анимация, но и добавляет элемент в композитный слой еще до того, как вы начинаете анимировать элемент.</li>
                        <li>&#10066; filter.</li>
                    </ol>
                    <p><span>Важно: </span>2D-анимация выполняется браузером на лету. Как только вы указываете 1-й и 5-й пункты, браузер уже знает, как ему надо строить DOM, что у него находится в композитных слоях, и не тратится на операцию repaint.</p>
                </div>
            </div>
            <div class="main-content-block track">
                <div class="content-block">
                    <h2 id="track-header">Как отследить работу анимации в браузере</h2>
                    <p>Теперь определим, какие именно элементы попадают в слои, по какой причине и сколько памяти расходуется на это действие.</p>
                    <div class="content-subblock">
                        <h3>Поиск слоев на странице</h3>
                        <p>Хочу обратить ваше внимание на классную тулзу в Google Chrome, которая поможет проверить, что именно попадет в композитный слой. Расскажу, как ее включить.</p>
                        <p>Заходите в DevTools -> More tools. Включаете вкладку Layers. И анимируемый элемент попадает в композитный слой. Вы увидите причину его попадания в композитный слой, а также сколько памяти будет занято на вычисление этой операции. Здесь можно увидеть, какие элементы отрисовываются постоянно, а какие — нет. Есть тулза Rendering в дополнительном DevTools в Chrome. Здесь можно включить Paint Flashing, который будет демонстрировать покадрово, что происходит с вашим элементом.</p>
                        <a href="https://s.dou.ua/storage-files/Video__1_final.mov" target="_blank">
                            <img src="img/06.PNG" alt="Видео пример поиска слоев на странице">
                        </a>
                    </div>
                    <div class="content-subblock">
                        <h3>Отладка композитных слоев</h3>
                        <p>Понаблюдать за композитным слоем можно с помощью этой же тулзы, просто переключившись в Layer Borders. Композитный слой будет помещен в оранжевую рамку, и будет понятно, что его можно отдебажить.</p>
                        <p>Помимо способа, описанного выше, хотелось бы рассказать, как можно понять, какой слой композитный, а какой задействует перерисовку макета целиком.</p>
                        <p>Есть тулза под названием Rendering. В ней есть различные настройки, но для того, чтобы отследить композитный слой, нас интересует Paint flashing. При включении этой опции слой помещается в рамку и показывается, сколько раз он перерисовывается. Так вот, в случае со свойством left на видео № 1 можно увидеть, что объект перерисовывается постоянно в каждом кадре.</p>
                        <a href="https://s.dou.ua/storage-files/Video_2_final.mov" target="_blank">
                            <img src="img/07.PNG" alt="Отладка композитных слоев видео">
                        </a>
                        <p>А в случае с использованием смещения transform он перерисовывается в начале и в конце анимации, то есть всего два раза.</p>
                        <a href="https://s.dou.ua/storage-files/Video_3_final.mov">
                            <img src="img/08.PNG" alt="Отладка композитных слоев второе видео">
                        </a>
                        <p>Можно посмотреть и на слайд анимации без композиции в тулзе Performance. Я запустил перезагрузку. На второй линии столбцы показывают процесс перерисовки элемента.</p>
                        <div class="content-img">
                            <img src="img/09.png" alt="Тулз Performance">
                        </div>
                        <p>То есть если вы будете неправильно анимировать, а неправильно — это значит с помощью смещения left, то перерисовка будет происходить каждый раз и анимация будет подтормаживать.</p>
                    </div>
                    <div class="content-subblock">
                        <h3>Отладка шагов CRP</h3>
                        <p>С помощью того же инструмента и EventLog можно также убедиться в затратности этого процесса.</p>
                        <div class="content-img">
                            <img src="img/10.png" alt="Инструмент EventLog">
                        </div>
                        <p>Теперь на реальном примере рассмотрим отличия двух подходов к реализации анимации. Допустим, перед нами стоит задача смещать элемент по оси Х на 500 пикселей от верхней левой границы экрана. Казалось бы, задача достаточно тривиальная. Какие есть варианты?</p>
                        <p><span>Вариант № 1</span> — сделать это с помощью свойства left.</p>
                        <a href="https://s.dou.ua/storage-files/Video_4_final.mov" target="_blank">
                            <img src="img/11.PNG" alt="Видео пример применения свойства left">
                        </a>
                        <p>Как это увидел браузер? Судя по видео, на каждое смещение пикселя выполняются всем нам знакомые 4 шага: Styles -> Layout -> Paint -> Composite.</p>
                        <p>Например, если нам нужно сместить элемент на 500 пикселей, то такие шаги будут выполняться 500 раз каждый. Представляете себе нагрузку на ЦП, если, помимо одного элемента, у нас еще и другие элементы будут смещаться, не говоря уж об их перерисовке относительно нашего.</p>
                        <p><span>Вариант № 2 </span>— смещение с помощью свойства transform.</p>
                        <a href="https://s.dou.ua/storage-files/Video_5_final.mov" target="_blank">
                            <img src="img/12.PNG" alt="Видео смещение с помощью свойства transform">
                        </a>
                        <p>Теперь при взгляде на результаты мы можем увидеть, что количество шагов для одного кадра уменьшилось и происходит пересчет стилей и вызов композитного слоя. В чем профит? Мало того, что мы с вами уменьшили количество шагов для отрисовки, так еще и перенесли нагрузку на видеоадаптер.</p>
                        <p>В то же время с этим подходом надо быть очень аккуратным, так как он может повлечь за собой процесс неявной композиции.</p>
                        <p>Неявная композиция — процесс, в котором один или несколько элементов, которые по Z-индексу находятся выше композитного элемента, также становятся композитными. То есть они отрисовываются в отдельное изображение, которое затем отправляется на GPU.</p>
                    </div>
                </div>
            </div>
            <div class="main-content-block differences">
                <div class="content-block">
                    <h2 id="differences-header">Чем отличаются JS и CSS и что лучше использовать для создания анимации</h2>
                    <span>JS</span>
                    <div class="content-block plus">
                        <p>&#9745; Полный контроль над анимацией. Вы можете полностью управлять анимацией, но тогда вы теряете заветные 60 fps, которые дают высокое качество картинки.</p>
                        <p>&#9745; Синхронизация с частотой обновления экрана. Операции, которые выполняются с помощью JS-анимации, выводятся с частотой, с которой обновляется этот экран. Вы не ощущаете никаких задержек.</p>
                    </div>
                    <div class="content-block minus">
                        <p>&#9746; Забивание основного потока. Если будет ошибка ниже или выше в CSS, то ваша анимация просто перестанет работать.</p>
                    </div>
                    <span>CSS</span>
                    <div class="content-block plus">
                        <p>&#9745; Простота в использовании. Например, чтобы заставить элемент вращаться по кругу, вам не надо проводить тематические операции. Это все быстро решается с помощью transform’a, к примеру.</p>
                        <p>&#9745; Свобода от основного потока. Если у вас есть где-то ошибки в коде, ваша анимация будет работать.</p>
                        <p>&#9745; Синхронизация с частотой обновления экрана.</p>
                    </div>
                    <div class="content-block minus">
                        <p>&#9746; Неконтролируемость. У вас нет полного контроля над своей анимацией, кроме паузы и запуска.</p>
                        <p>&#9746; Рассинхронизация. Вы не можете управлять элементами относительно друг друга.</p>
                    </div>
                </div>
            </div>
            <div class="main-content-block conclusions">
                <div class="content-block">
                    <h2 id="conclusions-header">Советы и выводы</h2>
                    <ol>
                        <li>&#10066; Относитесь к GPU, как к кешу. Все, что попадает в композитный слой, уходит и в память видеокарты. Поэтому важно не забивать ненужными элементами GPU. Это может привести к тормозам или крэшу браузера.</li>
                        <li>&#10066; Подготавливайте текстуры заранее.</li>
                        <li>&#10066; Избегайте неявной композиции.</li>
                        <li>&#10066; Используйте дружелюбные GPU свойства.</li>
                        <li>&#10066; Необходимо понять, как принудительно отрисовать объект в GPU с помощью transform hack.</li>
                        <li>&#10066; Учтите: рендеринг в GPU влияет на сглаживание шрифтов. Это происходит потому, что в GPU и CPU разные механизмы рендеринга. То есть если отключить аппаратное ускорение в конце анимации, то на протяжении всей анимации текст будет размытым.</li>
                    </ol>
                </div>
            </div>
        </div>
    </main>
    <footer>
        <div class="footer-content">
            <div class="footer-content-block copy">
                <p>Все права <span>почти</span> защищены &copy;</p>
                <p>Ссылка на оригинальную статью - <a href="https://dou.ua/lenta/articles/css-animation/" target="_blank">Плавность анимации CSS: миф или реальность</a> &reg;</p>
            </div>
        </div>
    </footer>
</body>
</html>